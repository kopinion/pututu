*** 名词
**** display rate(fps)
     内容层面的事情，一秒显示多少帧图片
**** fresh rate(hz)
     硬件层面的事情，一秒刷新多少次
**** response time
     很多时候，我们追求跟高的 fps 不是因为视觉问题，而是因为响应时间的问题。比如 VR 需要 90 fps 来达到要求的响应时间。

** 2. The Graphics Rendering Pipeline

*** 2.1 Architure
    粗粒度可以将实时渲染管线分为四个阶段：application(应用), geometry processing(几何处理), rasterization(光栅化), pixel processing(像素处理).
    每一个大的阶段（stage）， 可以被划分为更小的 substage. 即在每个 stage 中有更小的 pipeline 在中间。

    Application stage 通过应用程序来驱动，所以这个阶段的代码都跑在通用 CPU 上。以前一些任务－－碰撞检测，物理模拟都在CPU 处理
    geometry stage: 解决的几个问题：该画什么，怎么画，画在哪里。 主要处理几何转换，投影，以及其他的几何处理。这个阶段主要是在 GPU 运行，可以使用多个核，并发处理
    rasterization  state: 拿到三个顶点，组成一个三角形，找到在三角形中的所有像素，并标记，传给下一个 stage. 一般在 GPU 进行
    pixel processing stage: 对于每一个像素，执行一小段代码，决定其颜色，以及进行深度测试，决定当前像素应该显示，还是应该隐藏。或者还有和以前的颜色进行混合之类的操作。一般在 GPU 进行
*** 2.2 Application Stage
    开发人员在这个阶段可以控制所有的行为，因为这些东西都是在 CPU 上执行的。这个阶段会影响后面的性能。比如更改算法减少一些三角形。

    Application 阶段的一些工作可以在 GPU 执行，但是需要使用一种分离的模式：compute shader. 这种情况下，GPU 被当作高并发的通用处理器。

    Application 最后阶段，会把几何结构送到 geometry processing stage. 这些几何结构我们称之为渲染图元，比如点，线，三角形。

    因为这个阶段都是以软件为基础的实现，所以这个阶段不像其他的阶段，是分成 pipeline 结构的。

    这个阶段主要会处理一些在后面渲染 pipeline 里无法处理的事情。比如 碰撞检测，键盘时间处理之类的事情。
*** 2.3 Geometry Procession(几何处理)

    这个阶段主要会做一些针对三角形，或者顶点的操作。这个阶段可以被细分为更小的阶段，分别为

    #+BEGIN_SRC ditaa :file ./realtime-render/geometry_processing_pipeline.png :exports results
    +---------------+    +---------------+   +---------------+   +---------------+
    |               |    |               |   |               |   |     Screen    |
    |    Vertex     |    |  Projection   |   |    Clipping   |   |    Mappming   |
    |   Shading     |--> |               |-->|               |-->|               |
    |               |    |               |   |               |   |               |
    +---------------+    +---------------+   +---------------+   +---------------+
    #+END_SRC

    #+RESULTS:
    [[file:./realtime-render/geometry_processing_pipeline.png]]

**** 2.3.1 顶点着色（Vertex Shading）
     顶点着色主要会做两件事情：1. 计算顶点位置，2. 计算由程序员指定为顶点相关的数据，并将其输出， 比如顶点的法向量，或者顶点的纹理座标等等

     之所以会角顶点着色器是因为：一般情况下，我们通过将光线作用在每一个顶点上来计算阴影，然后在顶点数据上存储计算出阴影的颜色结果。这些数据通过插值的方式作用在三角形上。因为这个原因，这种可编程的顶点处理的过程就被
     称之为顶点着色器。

     我们一般情况下指定一个模型（三角形，或者球体）都是以当前模型为主题的座标系上指定，我们称这种座标系为模型座标系（model space）

     每个模型都可以应用模型转换过程，用来移动或者旋转相应的模型。一般情况下我们这个用模型转换过程将模型放置在世界座标系中。在整个应用程序中，只有一个世界座标系。

     只有能被看到的物体才会被渲染，在整个场景中，一般会有一个摄像机，这个摄像机有自己的位置，有自己的方向，还有自己的正反，我们需要将模型转换到相机所在的座标系才能知道，我们的模型能否被渲染，这一部一般被称之为视图转换。
     相机所处的座标系一般被称之为 观察座标系，或者相机座标系，或者视线座标系。


**** NEXT 在此处插入座标系转换的图片

     顶点着色器还有一部分功能就是，投影和裁剪。投影有：平行投影（正交投影）和透视投影。通过指定投影方式， 我们可以对物体进行变化，变换后我们的物体处于裁剪座标系中。
     通过定义视景体，我们可以得到一个立体的几何图形。通过计算知道，哪些顶点处于立体之内，哪些处于立体之外就可以完成模型的裁剪。


**** 2.3.2 可选的顶点处理

     所有的渲染管线会经过上面描述的顶点处理。上面的顶点处理结束之后可以选择一些其他的步骤对顶点进一步的处理，这些步骤包括 1. 细分着色，几何着色，和图元装配。

     细分着色的主要应用场景是： 假设你有一个球体，我们通常使用一组三角形来模拟球体。如果我们使用的三角形比较少，当球体比较远的时候，效果可以接受，但是当球体离观察点比较近的时候，球体会显示的比较粗糙。
     我们可以使用比较多的三角形来来模拟球体，但是当球体比较远的时候， 有可能最终渲染出来只有几个像素，这种情况下我们使用这么多三角形就会很浪费性能，这种情况下我们可以使用细分着色的方式来进行处理。
    点可以用来描述曲线，三角形，也可以用来描述曲面。这些曲面可以使用一些列的面片来表示，面片就是由一系列的点所组成。细分着色器通过使用面片（patch） 来描述一个物体。

     细分着色还能被分为几个子阶段：壳着色器（hull shader）， 细分着色器（tessellator）， 区域着色器（domain shader）。 通过这些阶段，可以将面片转换根多 /更少的顶点，然后通过这一组新的顶点来组成三角形。
     相机的位置来决定多少三角形或者顶点生成。
